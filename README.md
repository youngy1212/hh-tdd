
### 요구 사항
- PATCH  `/point/{id}/charge` : 포인트를 충전한다.
  - [x] Positive : 포인트를 충전한다. 
  - [x] Negative : 충전할 금액이 음수거나, 0 이다.
  - [x] Negative : 포인트 충전 금액이 최대 포인트를 초과.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
  - [x] Positive : 포인트가 사용된다.
  - [x] Negative : 사용 가능한 포인트 잔액이 부족하다 (실패).
- GET `/point/{id}` : 포인트를 조회한다.
  - [x] Positive : 포인트가 정상적으로 조회된다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
  - [x] Positive : 포인트 내역이 정상적으로 조회된다. 
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 한다.
- 동시에 여러 건의 포인트 충전, 이용 요청이 들어올 경우 순차적으로 처리되어야 한다.

### 동시성 테스트 
- 같은 유저가 동시에 포인트 충전 시 순차적으로 진행하여 충전 결과가 (초기 잔액 + 충전액) 이다.  <br>
  - 시나리오 : <br>
    ** 스레드 문제로 시나리오 변경 
    1. 현재 잔액은 9000 포인트 
    2이후 10번째 까지의 9000 충전 포인트 (성공) : 잔액 99000원
  - 검증 :
    1. 먼저 처리된 충전이 성공해야함.
    2. Dirty-Read 없이. 총 금액이 초기 잔액 + 충전액 이어야함.

- 같은 유저가 동시에 여러건의 포인트 사용 요청시 순차적으로 처리 후 잔액 부족시 실패
  - 시나리오
    ** 스레드 문제로 시나리오 변경 및 분리
    1. 현재 잔액 : 3000 포인트
    2. 첫 번째 사용 2000 포인트 (성공) : 잔액 1000원
    3. 이후 10번째까지 사용 2000 포인트 (실패) : 잔액 1000원
  - 검증
    1. 먼저 처리된 사용만 성공해야함.
    2. 잔액 부족시 사용 실패해야함.
    3. 성공과 실패 횟수에 대한 검증을 추가 

- 서로 다른 유저의 포인트 충전 및 사용 시 병렬 처리 확인
  - 시나리오
    1. 유저 A : 잔액 1000 포인트
    2. 유저 A : 충전 요청 500 포인트  : 잔액 6000원
    3. 유저 B : 잔액 5000 포인트
    4. 유저 B : 사용 요청 200 포인트  : 잔액 3000원
  - 검증 
    1. 동시에 처리되야함.
    2. 잔액이 정확하게 일치해야함.
    

## 변경사항
### **Before**

- **테스트 로직**

  첫 번째 요청과 두 번째 요청이 **순차적으로 실행되는지**를 검증하는 로직.

- **문제점**
  1. **스레드 개수**를 2개로 설정하여 테스트를 실행.
     - 동일한 코드로 테스트를 실행했음에도 **성공하거나 실패하는 비일관적인 결과**가 발생.

       ![image](https://github.com/user-attachments/assets/c6af1344-7e6b-468a-af6e-1dfff68d3cc1)
       ![image](https://github.com/user-attachments/assets/504a79b5-8d00-4bd0-b00e-085138468b50)

     - **RED 단계**에서 동시성 처리가 미 구현된 상태임에도, **테스트가 성공**하는 잘못된 로직이 존재.
  2. **스레드 개수가 적을 경우**, 운 좋게 테스트가 성공하는 경우가 생김.
     - 동시성 문제를 제대로 검출하지 못함.

### **After**

- 개선 사항
  1. **스레드 개수**를 10개로 증가.
     - 첫 번째부터 열 번째까지의 요청이 동시에 실행되도록 테스트 케이스를 변경.
  2. **테스트 결과**
     - 10개의 스레드가 동시에 요청을 처리하는 과정에서 **Dirty-Read 문제**가 발생.
     - **RED 단계에서 실패**하는 테스트 로직으로 변경되어, 동시성 문제가 명확히 드러남.

### Before

- **테스트 로직:**

  동일한 유저가 여러 포인트 사용 요청 시, 요청을 순차적으로 처리 후 잔액 부족 상태에서 실패하도록 검증.

- **문제점:**
  1. **테스트 성공 오류:**
     - 잔액 부족 상태에서도 테스트가 성공하는 오류 발생.

     ![image](https://github.com/user-attachments/assets/c9e1f38f-a8ee-4c96-b32b-bff680c950ba)

  2. **오류 발생 원인:**
     - `catch (Exception e) {}` 코드 블록이 없어서 예외가 내부에서 처리됨.
     - 예외가 발생해도 테스트가 실패하지 않음.

### After

- **개선 사항:**
  1. **예외 처리 추가:**
     - `catch (Exception e) { failureCount.incrementAndGet(); }` 블록을 추가하여 예외 발생 시 실패 카운트를 증가하도록 수정.
  2. **검증 로직 강화:**
     - 성공과 실패에 대한 횟수를 카운트하여 검증
- **테스트 결과:**
   - 동시성 문제가 명확히 드러나고, 테스트가 올바르게 동작함.
     ![image](https://github.com/user-attachments/assets/8de886b7-eb0d-40a7-ad89-3815c024ae35)

### 추가 개선사항

- **문제점:**
1. 이전 테스트에서는 **순차적 실행**과 **로직 검증**을 한 번에 처리하여 동시성 테스트의 본질이 방해받음.
2. 실패 원인을 명확히 파악하기 어려움.

- **개선 사항:**
  <br>테스트 케이스를 아래와 같이 분리 및 명확화:
  - 포인트 충전 : 
    - Before : 같은 유저가 동시에 포인트 충전 시 순차적으로 진행하여 최대 충전 한도 초과시 실패
    - After : 같은 유저가 동시에 포인트 충전 시 순차적으로 진행하여 충전 결과가 (초기 잔액 + 충전액) 이다.
  - 포인트 사용 : 
    - Before :같은 유저가 동시에 여러건의 포인트 사용 요청시 순차적으로 처리 후 잔액 부족시 실패 
    - After1 : 같은 유저가 동시에 여러건의 포인트 사용 요청시 순차적으로 실행한다.
    - After2 :  같은 유저가 동시에 여러건의 포인트 사용 요청시 순차적으로 실행한다.두 번째 사용에서 잔액 부족으로 실패한다.
